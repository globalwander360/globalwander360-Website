Perfect â€” letâ€™s add proper email validation in the backend authentication module. We'll do this at both:

1. DTO level â€“ using validation annotations (like @Email, @NotBlank)


2. Controller level â€“ enabling validation using @Valid


3. Exception Handling â€“ to return friendly validation messages (optional but useful)




---

âœ… Updated Code with Email Validation


---

ðŸ“„ SignupRequest.java â€“ Add validation annotations

package org.policy.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import org.policy.entity.Role;

@Data
public class SignupRequest {

    @NotBlank(message = "Username is required")
    private String username;

    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;

    @NotBlank(message = "Password is required")
    private String password;

    private Role role;
}


---

ðŸ“„ LoginRequest.java â€“ Add validation annotations

package org.policy.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class LoginRequest {

    @NotBlank(message = "Username is required")
    private String username;

    @NotBlank(message = "Password is required")
    private String password;
}


---

ðŸ“„ AuthController.java â€“ Enable validation using @Valid

package org.policy.controller;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.policy.dto.LoginRequest;
import org.policy.dto.SignupRequest;
import org.policy.dto.AuthResponse;
import org.policy.service.AuthService;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final AuthService authService;

    @PostMapping("/signup")
    public AuthResponse signup(@RequestBody @Valid SignupRequest request) {
        return authService.signup(request);
    }

    @PostMapping("/login")
    public AuthResponse login(@RequestBody @Valid LoginRequest request) {
        return authService.login(request);
    }
}


---

(Optional) ðŸ“„ Global Exception Handler â€“ Return clean validation messages

package org.policy.config;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<?> handleValidationErrors(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();

        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String msg = error.getDefaultMessage();
            errors.put(fieldName, msg);
        });

        return ResponseEntity.badRequest().body(errors);
    }

    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<?> handleRuntime(RuntimeException ex) {
        return ResponseEntity.badRequest().body(Map.of("error", ex.getMessage()));
    }
}


---

âœ… Sample Test: Signup with invalid email

POST /api/auth/signup

{
  "username": "testuser",
  "email": "invalid-email",
  "password": "pass123",
  "role": "USER"
}

Response

{
  "email": "Invalid email format"
}


---

Let me know if you'd like:

Password strength checks

Unique username/email checks at controller level too

Frontend side validation as well


Ready to plug this into your existing Spring Boot app!

