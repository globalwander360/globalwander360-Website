Great! For Day 3: Goods Registration, here's the full updated runnable code and project structure to support the task, assuming your Day 2 DTOs are correct.


---

Day 3 Directory Structure

src/main/java/com/example/inventory/
├── controller/
│   └── GoodsController.java
├── dto/
│   └── GoodsDTO.java         (From Day 2)
├── entity/
│   ├── Goods.java
│   └── Category.java         (used for mapping)
├── mapper/
│   ├── GoodsMapper.java
│   └── CategoryMapper.java   (added in Day 3)
├── repository/
│   ├── GoodsRepository.java
│   └── CategoryRepository.java
├── service/
│   ├── GoodsService.java
│   └── impl/
│       └── GoodsServiceImpl.java

src/test/java/com/example/inventory/
├── service/
│   └── GoodsServiceImplTest.java


---

1. GoodsMapper.java

@Mapper(componentModel = "spring", uses = {CategoryMapper.class})
public interface GoodsMapper {
    GoodsDTO toDto(Goods goods);
    Goods toEntity(GoodsDTO dto);
}


---

2. CategoryMapper.java

@Mapper(componentModel = "spring")
public interface CategoryMapper {
    CategoryDTO toDto(Category category);
    Category toEntity(CategoryDTO dto);
}


---

3. GoodsService.java

public interface GoodsService {
    GoodsDTO save(GoodsDTO goodsDTO);
    GoodsDTO findById(Long id);
}


---

4. GoodsServiceImpl.java

@Service
@RequiredArgsConstructor
public class GoodsServiceImpl implements GoodsService {
    private final GoodsRepository goodsRepository;
    private final GoodsMapper goodsMapper;

    @Override
    public GoodsDTO save(GoodsDTO goodsDTO) {
        Goods entity = goodsMapper.toEntity(goodsDTO);
        return goodsMapper.toDto(goodsRepository.save(entity));
    }

    @Override
    public GoodsDTO findById(Long id) {
        return goodsRepository.findById(id)
                .map(goodsMapper::toDto)
                .orElseThrow(() -> new RuntimeException("Goods not found"));
    }
}


---

5. GoodsRepository.java

@Repository
public interface GoodsRepository extends JpaRepository<Goods, Long> {
}


---

6. GoodsController.java

@RestController
@RequestMapping("/api/goods")
@RequiredArgsConstructor
public class GoodsController {
    private final GoodsService goodsService;

    @PostMapping
    public ResponseEntity<GoodsDTO> create(@RequestBody GoodsDTO dto) {
        return new ResponseEntity<>(goodsService.save(dto), HttpStatus.CREATED);
    }

    @GetMapping("/{id}")
    public ResponseEntity<GoodsDTO> get(@PathVariable Long id) {
        return ResponseEntity.ok(goodsService.findById(id));
    }
}


---

7. GoodsServiceImplTest.java

@ExtendWith(MockitoExtension.class)
public class GoodsServiceImplTest {

    @InjectMocks
    private GoodsServiceImpl goodsService;

    @Mock
    private GoodsRepository goodsRepository;

    @Mock
    private GoodsMapper goodsMapper;

    @Test
    void testSave() {
        GoodsDTO dto = new GoodsDTO();
        Goods entity = new Goods();

        when(goodsMapper.toEntity(dto)).thenReturn(entity);
        when(goodsRepository.save(entity)).thenReturn(entity);
        when(goodsMapper.toDto(entity)).thenReturn(dto);

        GoodsDTO saved = goodsService.save(dto);

        assertNotNull(saved);
        verify(goodsRepository).save(entity);
    }

    @Test
    void testFindById() {
        Goods entity = new Goods();
        GoodsDTO dto = new GoodsDTO();

        when(goodsRepository.findById(1L)).thenReturn(Optional.of(entity));
        when(goodsMapper.toDto(entity)).thenReturn(dto);

        GoodsDTO found = goodsService.findById(1L);

        assertNotNull(found);
        verify(goodsRepository).findById(1L);
    }
}


---

Would you like me to also provide the updated Goods.java and Category.java entity files to make sure everything is aligned?



Perfect! Here's the updated and complete entity code for Day 3: Goods Registration — these match your DTOs and mapper logic to ensure smooth conversion and persistence.


---

1. Category.java

package com.example.inventory.entity;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "category")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Category {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String name;

    @Column(length = 500)
    private String description;

    @Column(name = "storage_requirements", length = 500)
    private String storageRequirements;

    @Column(name = "is_perishable")
    private Boolean isPerishable;

    @Column(name = "shelf_life")
    private Integer shelfLife;
}


---

2. Goods.java

package com.example.inventory.entity;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
@Table(name = "goods")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Goods {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private Integer quantity;

    @Column(name = "unit_of_measure")
    private String unitOfMeasure;

    private String location;

    @Column(name = "expiry_date")
    private LocalDate expiryDate;

    @Column(name = "acquisition_date")
    private LocalDate acquisitionDate;

    @Column(name = "minimum_stock_level")
    private Integer minimumStockLevel;

    private BigDecimal price;

    private String supplier;

    private String status;

    @ManyToOne
    @JoinColumn(name = "category_id")
    private Category category;
}


---

These entities are annotated with Jakarta (if you're using Spring Boot 3+) and match the fields used in your mappers and service layer. Let me know if you'd like the Liquibase XML for these tables verified too.


