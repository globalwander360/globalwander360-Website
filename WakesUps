",
  "remarks": "Looks good",
  "goodsId": 1
}


---

Would you like me to now proceed with Frontend Angular structure and full source code for this Quality Check feature (Day 5)?
Sure! Letâ€™s create an enum for status values (PENDING, APPROVED, and REJECTED) and implement it in the backend across the Goods and QualityCheck sections accordingly.


---

1. Create the Enum

package org.policy.enums;

public enum GoodsStatus {
    PENDING,
    APPROVED,
    REJECTED
}


---

2. Update the Goods Entity

package org.policy.entity;

import jakarta.persistence.*;
import lombok.*;
import org.policy.enums.GoodsStatus;

import java.time.LocalDate;

@Entity
@Table(name = "goods")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Goods {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private Integer quantity;

    @Column(name = "unit_of_measure")
    private String unitOfMeasure;

    private String location;

    @Column(name = "expiry_date")
    private LocalDate expiryDate;

    @Column(name = "acquisition_date")
    private LocalDate acquisitionDate;

    @Column(name = "minimum_stock_level")
    private Integer minimumStockLevel;

    private Double price;
    private String supplier;

    @Enumerated(EnumType.STRING)
    private GoodsStatus status = GoodsStatus.PENDING;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id")
    private Category category;
}


---

3. Update the QualityCheck Entity

package org.policy.entity;

import jakarta.persistence.*;
import lombok.*;
import org.policy.enums.GoodsStatus;

import java.time.LocalDate;

@Entity
@Table(name = "quality_check")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class QualityCheck {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String inspectorName;
    private LocalDate checkDate;

    @Enumerated(EnumType.STRING)
    private GoodsStatus status;

    private String remarks;

    @OneToOne
    @JoinColumn(name = "goods_id")
    private Goods goods;
}


---

4. Update QualityCheckDTO

package org.policy.dto;

import lombok.*;
import org.policy.enums.GoodsStatus;

import java.time.LocalDate;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class QualityCheckDTO {
    private Long id;
    private String inspectorName;
    private LocalDate checkDate;
    private GoodsStatus status;
    private String remarks;
    private Long goodsId;
}


---

5. Update QualityCheckServiceImpl

No changes to logic, but now it works with GoodsStatus enum:

goods.setStatus(dto.getStatus()); // dto.getStatus() is now of type GoodsStatus


---

6. Sample JSON (Updated with Enum)

{
  "inspectorName": "Rajeev Singh",
  "checkDate": "2025-04-14",
  "status": "APPROVED",
  "remarks": "All good. No issues found.",
  "goodsId": 2
}


---

Let me know if you want me to now generate the frontend code for the Logistics Coordinator section to review and approve goods using this enum setup.



Great! Below is the complete structure and full backend source code for Day 5: Quality Check using an enum for GoodsStatus with values: PENDING, APPROVED, and REJECTED.


---

1. Enum: GoodsStatus

// src/main/java/org/policy/enums/GoodsStatus.java
package org.policy.enums;

public enum GoodsStatus {
    PENDING,
    APPROVED,
    REJECTED
}


---

2. Entity: GoodsReview

// src/main/java/org/policy/entity/GoodsReview.java
package org.policy.entity;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "goods_review")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class GoodsReview {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String comment;

    private LocalDateTime reviewedAt;

    @Enumerated(EnumType.STRING)
    private org.policy.enums.GoodsStatus status;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "goods_id")
    private Goods goods;
}


---

3. DTO: GoodsReviewDto

// src/main/java/org/policy/dto/GoodsReviewDto.java
package org.policy.dto;

import lombok.*;
import org.policy.enums.GoodsStatus;

import java.time.LocalDateTime;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class GoodsReviewDto {
    private Long id;
    private Long goodsId;
    private String comment;
    private GoodsStatus status;
    private LocalDateTime reviewedAt;
}


---

4. Mapper: GoodsReviewMapper

// src/main/java/org/policy/mapper/GoodsReviewMapper.java
package org.policy.mapper;

import org.policy.dto.GoodsReviewDto;
import org.policy.entity.GoodsReview;
import org.policy.entity.Goods;

public class GoodsReviewMapper {

    public static GoodsReview toEntity(GoodsReviewDto dto, Goods goods) {
        GoodsReview review = new GoodsReview();
        review.setId(dto.getId());
        review.setComment(dto.getComment());
        review.setStatus(dto.getStatus());
        review.setReviewedAt(dto.getReviewedAt());
        review.setGoods(goods);
        return review;
    }

    public static GoodsReviewDto toDto(GoodsReview review) {
        return new GoodsReviewDto(
            review.getId(),
            review.getGoods().getId(),
            review.getComment(),
            review.getStatus(),
            review.getReviewedAt()
        );
    }
}


---

5. Repository: GoodsReviewRepository

// src/main/java/org/policy/repository/GoodsReviewRepository.java
package org.policy.repository;

import org.policy.entity.GoodsReview;
import org.springframework.data.jpa.repository.JpaRepository;

public interface GoodsReviewRepository extends JpaRepository<GoodsReview, Long> {
}


---

6. Service Interface: GoodsReviewService

// src/main/java/org/policy/service/GoodsReviewService.java
package org.policy.service;

import org.policy.dto.GoodsReviewDto;

public interface GoodsReviewService {
    GoodsReviewDto reviewGoods(Long goodsId, GoodsReviewDto dto);
}


---

7. Service Implementation

// src/main/java/org/policy/service/impl/GoodsReviewServiceImpl.java
package org.policy.service.impl;

import lombok.RequiredArgsConstructor;
import org.policy.dto.GoodsReviewDto;
import org.policy.entity.Goods;
import org.policy.entity.GoodsReview;
import org.policy.enums.GoodsStatus;
import org.policy.mapper.GoodsReviewMapper;
import org.policy.repository.GoodsRepository;
import org.policy.repository.GoodsReviewRepository;
import org.policy.service.GoodsReviewService;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
public class GoodsReviewServiceImpl implements GoodsReviewService {

    private final GoodsRepository goodsRepository;
    private final GoodsReviewRepository goodsReviewRepository;

    @Override
    public GoodsReviewDto reviewGoods(Long goodsId, GoodsReviewDto dto) {
        Goods goods = goodsRepository.findById(goodsId)
                .orElseThrow(() -> new RuntimeException("Goods not found"));

        if (dto.getStatus() == GoodsStatus.REJECTED && (dto.getComment() == null || dto.getComment().isBlank())) {
            throw new RuntimeException("Comment is required for rejection");
        }

        goods.setStatus(dto.getStatus());
        goodsRepository.save(goods);

        GoodsReview review = GoodsReviewMapper.toEntity(dto, goods);
        review.setReviewedAt(LocalDateTime.now());

        GoodsReview savedReview = goodsReviewRepository.save(review);
        return GoodsReviewMapper.toDto(savedReview);
    }
}


---

8. Controller: GoodsReviewController

// src/main/java/org/policy/controller/GoodsReviewController.java
package org.policy.controller;

import lombok.RequiredArgsConstructor;
import org.policy.dto.GoodsReviewDto;
import org.policy.service.GoodsReviewService;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/reviews")
@RequiredArgsConstructor
public class GoodsReviewController {

    private final GoodsReviewService service;

    @PostMapping("/{goodsId}")
    public GoodsReviewDto reviewGoods(@PathVariable Long goodsId, @RequestBody GoodsReviewDto dto) {
        return service.reviewGoods(goodsId, dto);
    }
}


---

9. Update Goods Entity

Make sure this is in Goods.java:

@Enumerated(EnumType.STRING)
private GoodsStatus status;

@OneToOne(mappedBy = "goods", cascade = CascadeType.ALL)
private GoodsReview goodsReview;


---

10. Sample JSON for Testing

Approved

{
  "status": "APPROVED",
  "comment": "Good quality item"
}

Rejected

{
  "status": "REJECTED",
  "comment": "Item has visible damage"
}


---

Let me know when you're ready for the frontend structure (Angular with PrimeNG and Reactive Forms) for Quality Check.


